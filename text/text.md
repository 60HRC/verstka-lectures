# Шрифты

## Что такое шрифт?

**Шрифт** – графический рисунок начертаний букв и знаков, составляющих единую стилистическую и композиционную систему,
набор символов определенного размера и рисунка.  

**Копьютерный шрифт** — это файл содержащий в себе набор графических символов и соответствующих им кодов. Символы могут
быть различными по назначению: языковые знаки, числа, графические, специальные и пр.  
В эпоху матричных принтеров и мониторов с низким разрешением царствовали растровые шрифты. Такие шрифты представляли
собой набор растровых изображений каждого символа в виде битмапа, состоящего из цветных пикселей. И при увеличении
размера шрифта его детализация не увеличивалась, и пикселизация была видна еще больше:  
![](http://www.myabandonware.com/media/screenshots/s/sid-meiers-civilization-1nj/sid-meiers-civilization_16.png)  

Позже появились векторные шрифты, описывающие символы с помощью математических формул, что позволяет их масштабировать
без потери качества, как и любое другое векторное изображение. Небольшой издержкой рендера такого шрифта является
несколько бОльшая нагрузка на процессор, т.к. перед растеризацией необходимо также расчитать различные кривые,
сглаживание линий и пр.  
![civilization](http://fr.ffonts.net/img/V/E/Vector.png)  

> [Статья Юрия Самарина про компьютерные шрифты](http://www.compuart.ru/article.aspx?id=23461&iid=1079)  

## Параметры шрифтов
Шрифты обладают обширным количеством параметров и особенностей, комбинированием которых решаются те или иные задачи.
В процессе развития типографики появилось шрифты стало возможно классифицировать, появилось множество параметров:  
![](https://upload.wikimedia.org/wikipedia/hu/a/a1/Fontmetrik%C3%A1k.png)  

### Гарнитура
Гарнитура – типографский термин, объединяющий набор шрифтов, которые отличаются по размеру, начертанию, наличию или
отсутствию засечек на концах линий, пропорциям символов, соотношению размера высоты прописных и строчных знаков,
величине верхних и нижних выносных элементов, плотности, то есть близких по характеру и отличительным знакам рисунка.
Примеры известных гарнитур: Arial, Times New Roman.  

### Базовая линия
Базовая линия — воображаемая прямая линия, проходящая по нижнему краю прямых знаков без учёта свисаний и нижних выносных
элементов. В строке символы текста стоят на базовой линии, а нижние выносные элементы текста «свисают» с неё.  
![](http://type_therminology.academic.ru/pictures/type_therminology/32.gif)

### X-height (Высота строчных знаков)
Высота строчных знаков — расстояние от базовой линии до верхней линии строчных, то есть высота строчных букв без
свисаний и выносных элементов.  
![](http://type_therminology.academic.ru/pictures/type_therminology/573.gif)

### Cap height (Высота заглавной буквы)
Высота заглавной буквы — расстояние от базовой линии до верхней линии прописных, то есть высота прописных букв без учета
свисаний.

### Свисание
Свисание — выступающая вниз за базовую линию (нижнее свисание) или вверх за верхнюю линию (верхнее свисание) часть
контура круглого или остроконечного знака. Применяется для оптического выравнивания высоты знака по отношению к соседним.  
![](http://type_therminology.academic.ru/pictures/type_therminology/252.gif)

### Leading
Интерлиньяж, межстрочный интервал — расстояние между базовыми линиями соседних строк. Так как в веб данный термин
называется высотой строки, дальше мы будем использовать именно его.  
![](http://sauron.org.ua/wp-content/uploads/2013/12/font.png)

### Em Square
Кегельная площадка – верхняя прямоугольная часть ножки литеры, на которой расположено выпуклое (печатающее) изображение
знака.
![](https://rawgit.com/urfu-2015/verstka-slides/master/04-fonts-text/img/em_metal.JPG)  
В цифровом шрифте кегельная площадка важна только при проектировании шрифта как прямоугольник, в который вписывается
изображение знака.  
![](https://rawgit.com/urfu-2015/verstka-slides/master/04-fonts-text/img/em_digital.jpg)

## CSS и шрифт
С помощью CSS можно влиять на множество параметров шрифта.

### Размер шрифта
С помощью `font-size` можно определить размер шрифта элемента. Размер шрифта определяется как высота от базовой линии до
верхней границы кегельной площадки:  
![](http://htmlbook.ru/files/images/css/css_font-size_1.png)  
Он может быть установлен несколькими способами. Набор констант (`xx-small`, `x-small`, `small`, `medium`, `large`,
`x-large`, `xx-large`) задает размер, который называется абсолютным. На самом деле они не совсем абсолютны, поскольку
зависят от настроек браузера и операционной системы.  

Другой набор констант (`larger`, `smaller`) устанавливает относительные размеры шрифта, зависящие от размера шрифта
родителя. Изменение составляет примерно 20%. Например, если размер шрифта родителя `20px`, то размер шрифта потомка с
`larger` будет составлять `24px`.  

Другой более популярный и рекомендуемый способ — использование единиц измерения CSS:
* `em`. Установка размера шрифта в зависимости от размера шрифта родителя. Например, если у родителя размер шрифта
`16px`, то значение `1.25em` будет расчитываться по формуле 16 * 1.25 и составит 20 пикселей. Обычно такой подход
используется, когда необходимо, чтобы блок подстраивался под различных родителей. Например, хочется для каждого вида
заголовков сделать подзаголовок с чуть меньшим размером шрифта:
```css
h1
{
    font-size: 25px;
}

h2
{
    font-size: 20px;
}

.sub-header
{
    font-size: 0.7em;
}
```

```html
<h1>
    Главный заголовок<br>
    <span class="sub-header">Подзаголовок</span>
</h1>

<h2>
    Важный заголовок<br>
    <span class="sub-header">Детали заголовка</span>
</h2>
```
![](https://leto26d.storage.yandex.net/rdisk/6a3e0697d20e2922cf60a6026571a1a77bfa05231d22c27a491912e94f9eaa83/inf/pEkTWZbNJxnvdRIGZkDsmvkZUZc9H1T84YkW8dhNl2bqoxzqlbbCqtwOwwxFY1_pfEwvl-kW0s1KTs6hjJvD4A==?uid=0&filename=2015-10-15%2018-17-06%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=b2ed0f7bc12107bd11b4cd3996ca7c66&force_default=no&ycrid=na-87f86c21ab08da9d88b7238d344fa3cb-downloader3d)  
Как видно на рисунке, элемент с одним и тем же классом смотрится по-разному в зависимости от окружения.

* `rem`. Подобно `em`, но зависит не от родительского размера шрифта, а от размера шрифта корневого элемента (`html`);  
* `%` как и `em` устанавливают размер шрифта, зависящий от родителя. Различия от `em` могут наблюдаться в редких случаях
и только при изменении размера шрифта в настройках браузера;  
* `px` позволяют указать размер шрифта в пикселях. Т.к. задание динамического размера требуется нечасто, эта единица
изменерния является наиболее популярной;  
* `ex` соответствует ширине символа `x`. Не рекомендуется к использованию;
* `ch` соответствует ширине символа `0` (ноль). Не рекомендуется к использованию;
* абсолютные единицы измерения `pt`, `pc`, `cm`, `mm`, `in` пришли из типографики и также не рекомендованы к
использованию для размера шрифта, т.к. могут очень по-разному выглядеть в зависимости от монитора\устройства.

> единица измерения `em` может быть использована не только для указания размера шрифта. Если указать отступ в `em`, то
> он так же будет зависать от размера шрифта родителя.

Следует учитывать, что связь свойства `font-size` с тем, что отображается на экране, в действительности определяется
разработчиком шрифта. Размер шрифта характеризуется *кегельной площадкой* (em square) (некоторые называют ее кегельным
квадратом) шрифта. Кегельная площадка (и соответственно размер шрифта) не задается границами каких-либо символов шрифта.
Эта величина определяется расстоянием между базовыми линиями, если шрифт задан без дополнительных межстрочных интервалов.
Шрифты могут иметь символы, размер которых превышает стандартное расстояние между базовыми линиями. Впрочем, шрифт может
быть определен так, что все его символы будут меньше, чем его кегельная площадка, что и наблюдается у многих шрифтов.
Таким образом, действие `font-size` состоит в задании размера кегельной площадки используемого шрифта. Это не гарантирует,
что любой из фактически отображаемых символов будет иметь такой размер.



### Высота строки
Высота строки (межстрочный интервал, интерлиньяж) — расстояние между базовыми линиями соседних строк. Устанавливается с
помощью свойства `line-height`. Устанавливать интервал можно с помощью трех типов значений: множителя, или единиц длины
и процентов.  
Множитель устанавливает интерлиньяж, равным размеру шрифта, умноженному на множитель:

```html
<p style="font-size: 20px; line-height: 1.5;">
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa.
</p>
```

В результате интерлиньяж будет равен 10px * 1.5 = 15px  
![line-height](https://leto42d.storage.yandex.net/rdisk/e61a7747c74f2009ab39267737ecfea6e75ac602db63c30ecffd9381a15c37b1/inf/UgQT9OQzAzE8pRDjCxmj8X8VOk6equnZlN1t3B_qbvnR7N6IrI5aF9UdNXnIJLUc7k5ee5cWQZY-DqpGoiIvvQ==?uid=0&filename=2015-10-05%2013-38-48%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=de0f8b58b6c4c6a2cdcbf1abf529b0df&force_default=no&ycrid=na-90f38ad4a20197ade567ae3a16cc747f-downloader10g)  

Пиксели, пункты, сантиметры и подобные им единицы длины позволяют указать независимое значение интерлиньяжа. Значение,
указанное в `em` или в процентах, так же, как и множитель, зависит от размера шрифта блока (умножается на него).
Различие между множителем и `em/%` заключется в том, как они наследуются дочерним элементам. Значение в `em/%`,
унаследованное от родителя, расчитывается умножением этого значения на _размер шрифта родителя_. А множитель,
унаследованный от родителя, рассчитыается умножением _размера шрифта дочернего элемента_ на множитель. Рассмотрим это на
примере:  

```html
.parent-em
{
    font-size: 16px;
    line-height: 1.1em; /* Эквивалентно line-height: 110%; */
}

.parent-number
{
    font-size: 16px;
    line-height: 1.1;
}

.child
{
    font-size: 30px;
}

<div class="parent-em">
    <p class="child">
        Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa.
    </p>
</div>

<div class="parent-number">
    <p class="child">
        Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa.
    </p>
</div>
```

В результате текст первого блока «слипся», т.к. при размере шрифта в 30 пикселей высота строки расчиталась исходя из
родительскиого размера шрифта и получилась равной 17.6 пикселей:  
![line-height-em](https://leto19g.storage.yandex.net/rdisk/9446f2af72d2e30476492e73713d68827e47649efef50a18aa8a5a9b4a995f37/inf/7zqhJeiAj85U55vDKPIqtGKGt9F5c0P4LZPcS-YIH0q4emhTmsoM-rfZ8yKlpK-smkcjHjWZflK8Q-UOJnEJmg==?uid=0&filename=2015-10-07%2015-51-01%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=bb1c32a9059f69de31e2a0150d36c4b6&force_default=no&ycrid=na-28f42ae900fe0bff8d397e99d8da34b9-downloader3g)  

А текст во втором блоке выглядит хорошо, т.к. множитель хоть и унаследовался от родителя, но умножается на размер шрифта
дочернего блока. Таким образом, высота строки получилась 33 пикселя:  
![line-height-number](https://leto22g.storage.yandex.net/rdisk/e86c7d3479cac02e874aa09fa1e003dcd93eaf6f65b98b3cc43b4f5f53e67d8a/inf/1IzQFcWkiGZ6GlnDOLxECDzpgEVK4rXMB8EwSHow-R7aP2t8a76dQeTe8ZiEFJ_aoGcAz1VnBad-Q88ukNaxHw==?uid=0&filename=2015-10-07%2015-55-44%20Mo8Il34oAD4LQnyiwX9PHL-AjHS44_6h2fW2jT9j2Z7fACOUAFQmW9mfbI6aFmidLsI8aduHroS3G020_Ps5ug%3D%3D%20%28570%C3%97192%29.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=bb1c32a9059f69de31e2a0150d36c4b6&force_default=no&ycrid=na-3c8f46680bbe9f90e80db53c8819a1ed-downloader2g)  

> По умолчанию высота строки равно примерно 1.2;

### Расстояние между буквами (Разрядка)
Разрядка — способ выделения текста, широко использующийся в традиционной русской типографике; заключается в увеличении
интервала между буквами. В вебе применяется редко, как правило в заголовках. Для изменения разрядка предусмотрено
свойство `letter-spacing`. Оно позволяет как увеличивать, так и уменьшать это расстояние.   
![](https://leto8g.storage.yandex.net/rdisk/f432d48590b673aa488561efa16c5a182531d978eb076aed682f45f0bf720681/inf/MVI6AZxo8GU7K7U6e8tSsjGrA1n82_2aMdPQwRRZm-x6Xz_dr_pf5yzAtN4C45j6bXld8ULSS2oQK7-2OrHX_Q==?uid=0&filename=2015-10-11%2002-03-11%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-b4acf5e2733154647e79bcf1324c716e-downloader4d)  
В качестве значений можно указывать любые единицы длины, кроме процентов. Современные браузеры позволяют указывать
дробные значения, например, `0.5px`.

### Расстояние между словами
Расстояния между словами можно изменить с помощью свойства `word-spacing`. В качестве значения можно указать любые
единицы длины, кроме процентов. Следует иметь в виду, что это свойство влияет только на обычные и неразрывные пробелы.

### Капитель
Капитель — это начертание в гарнитуре, в которой строчные знаки выглядят, как уменьшенные прописные. Установить такое
начертание можно с помощью свойства `font-variant` со свойством `small-caps`.  
![](http://htmlbook.ru/files/images/css/css_font-variant_1.png)  
Значение по умолчанию `normal`.

### Наклон
Наклон также используется, чтобы выделить выжные слова и фразы. Также часто используется в цитатах, как речь
автора. Существует два типа наклона: курсив (italic) и наклонный шрифт (oblique). Если курсив представляет собой
специально спроектированный шрифтовой набор, имеющий лишь отдаленное сходство с соответствующим прямым шрифтом, то
наклонный представляет собой лишь модифицированный прямой, слегка «заваленный» вправо. Наклон осуществляется с помощью
свойства `font-style` со значениями `italic` или `oblique`.  
![font-style](http://docstore.mik.ua/orelly/web2/css/figs/css.0524.gif)  
Значением по умолчанию является `normal`.

### Насыщенность
Насыщенность устанавливается при помощи свойства `font-weight`.  
![font-weight](http://fabricjs.com/article_assets/2_7.png)  
У этого свойства существует две катеогрии значений: числа и ключевые слова. Числами — это значения от 100 до 900,
кратные стам, т.е. `100`, `200`, `300`, `400`, `500`, `600`, `700`, `800` или `900`. Каждое числа является степенью
насыщенности. При этом `400` — это обычный вид текста и значение по умолчанию. `700` соответствует стилю текста «жирный»
в текстовых процссорах. Следует отметить, что степени, отличные от 400 и 700, встречаются значительно реже. Как
правило, это специализированные шрифты.  
Более часто для указания жирности используются ключевые слова. Средни них: `normal`, `bold`, `bolder` и `lighter`.
`bold` (соответствует `700`) является самым популярным и доступен для использования в каждом из системных шрифтов.

`bolder` и `lighter` — устаналивают степень жирности на один шаг в большую или меньшую сторону относительно уровня
родителя. При этом шаг не обязательно равен +100 или -100, а зависит от доступных уровней жирности. Например, если
родитель с `font-family: Arial` имеет `font-weight: normal`, то значение `bolder` у потомка будет эквивалентно значению
`bold`, т.к. `Arial` имеет лишь лишь градации `normal` (`400`) и `bold` (`700`).  

Браузер _не пытается_ сам отрисовать градации, отличные от `bold`. Если шрифт поставляется только со степенями `normal`
и `bold`, то при использовании числовых значений свойства `font-weight` браузер будет вести себя следующим образом:
значения 100-500 округляются до значения `normal` (`400`), 600-900 округяются до `bold` (`700`).  
Чтоб иметь возможность использовать множество градаций, следует подключать шрифты особым образом, о чем будет рассказано
ниже.  

> Существуют элементы, имеющие `font-weight: bold` по умолчанию, например: `<strong>`, `<b>`.

### Плотность
Плотность — один из признаков начертания шрифта, по которому шрифты в зависимости от зрительного соотношения ширины
знаков с их высотой делятся на шрифты узкого, нормального и широкого начертания (а также ротации). Например, в семействе
шрифтов Arial существует модификация Arial Narrow, символы которой узкие.  
![](https://leto16g.storage.yandex.net/rdisk/d466c21c177ba7e4860a8158add74cb7ad67363ddfcacdf27ff2fa88189740b2/inf/4ISIVCUW_AUPhUBFIH-TL3L-L5hB5eZ2qRjH-HfXQ81SNWCh9TfEoGouVHxLy2rJCOd8UsK0cLol7hBZpW-vxg==?uid=0&filename=2015-10-22%2003-24-01%20font_styles.gif%20%281642%C3%97769%29.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=0d7ab062b81dfa5f9f3ea76080da1f9c&force_default=no&ycrid=na-d676e09979027745d149e8804b2d73a2-downloader6e)  
В CSS для указания плотности используется свойство `font-stretch`, значениями которого являются градации плотности в
виде ключевых слов:
`ultra-condensed`, `extra-condensed`, `condensed`, `semi-condensed`, `normal`, `semi-expanded`, `expanded`,
`extra-expanded`, `ultra-expanded`;

Браузер не рендерит это свойство своими силами. Поэтому, чтоб оно работало, шрифт с каждой градацией нужно подключать
отдельно.

> На момент написания лекции браузеры Chrome и Safari не поддерживали это свойство.

## Категории шрифтов в вебе
В мире существует множество типов шрифтов. И также существуют различные иерархические классификации.
> [Классификация компании paratype](http://www.paratype.ru/help/class/)  

В вебе утверждено 5 видов шрифтов: с засечками, без засечек, моноширинные, рукописные, декоративные.    
Наиболее распространенные из них это шрифты с засечками и без засечек. Шрифт без засечек, как правило, состоит из линий
одинаковой толщины. У шрифта с засчеками есть эти самые засечки, которые располагаются на концах линий. Толщина линии
часто варьируется в мастах сгибов и не только.  
![](https://cloud.githubusercontent.com/assets/769992/10760452/6eca48aa-7cde-11e5-9014-bf16cbcddf20.png)  
Для различных ситуаций требуются гарнитуры с различными свойствами. Например, в книжном и газетном деле наиболее
распространены гарнитуры с засечками. Хотя об этом идет
[много споров](http://alexpoole.info/blog/which-are-more-legible-serif-or-sans-serif-typefaces/), но многими считается,
что шрифт с засечками менее утомитлен при чтении.  
Остальные типы шрифтов используются редко, для определенных ситуаций.

## Шрифты на сайте
В поставке каждой операционной системы имеется набор шрифтов. Существует ряд шрифтов, которые есть практически в каждой
из них, таким образом их использование считается наиболее безопасным.  Среди шрифтов без засечек таким шрифтом являются
Arial. Среди шрифтов с засечками — Times New Roman, среди моноширинных — Courier New.

Шрифт блока на сайте можно указать с помощью свойства `font-family`, например:
```css
.block
{
    font-family: 'Arial';
}
```

Имеется также возможность указать несколько шрифтов через запятую.
```css
.block
{
    font-family: Arial, Helvetica; /* Шрифты можно указывать без кавычек */
}
```
Если браузер не находит в системе первый в списке шрифт, он будет пытаться найти следующий, пока в конце концов не
использует шрифт браузера по умолчанию (обычно это Times New Roman). В последнем случае имеет смысл «сказать» браузеру
о категории шрифа, чтобы он мог выбрать более подходящий из имеющихся в системе. Для этого существуют пять ключевых
слов: `serif` (с засечками), `sans-serif` (без засечек) и `monospace` (моноширинный), `cursive` (рукописный) и `fantasy`
(декоративный).  
Окончательный вариант оптимального указания шрифта будет выглядеть так:  
```css
.block
{
    font-family: Arial, Helvetica, sans-serif;
}
```

## Подключение нестандартного шрифта
Существует возможность встраивать нестандартные (то есть отсутствющие в системе) шрифты на страницу. Например, такая
потребность может возникнуть из-за необходимости отобразить символ рубля.

### Подключение с помощью @font-face
Для подключения шрифтов используется правило `@font-face`, в котором необходимо указать название шрифта и адрес источника
шрифта:
```css
@font-face {
    font-family: myCustomFont;
    src: url(myCustomFont.woff); /* .woff — один из популярных форматов веб-шрифтов */
}
```

И затем для применения шрифта к блоку просто указать его имя в `font-family` (и не забыть указать запасные варианты
на случай, если хост с источником недоступен):

```css
body
{
    font-family: myCustomFont, sans-serif; /* либо serif, если подключаемый шрифт с засечками */
}
```

Как было сказано ранее, наклонный стиль и степени жирности шрифта (а также их комбинации) являются отдельными файлами.
Таким образом, чтоб задействовать курсивную версию шрифта, нам понадобится соответствующий файл шрифта. Мы можем просто
подключить курсивный шрифт, задав ему собственное имя:
```css
@font-face {
    font-family: myCustomItalicFont;
    src: url(myCustomItalicFont.woff); /* .woff — идин из популярный форматов веб-шрифтов */
}
```
и использовать его в нужных местах вместо `myCustomFont`
```css
em
{
    font-family: myCustomItalicFont, sans-serif;
}
```
однако такой вариант использования является неоптимальным, т.к. увеличение количества названий заставляет нас
запоминать название и его предназначение. Кроме того, нарушается семантика описания стиля шрифта, ведь более логичным
было бы использовать `font-style: italic` вместо `font-face`. Для получения такой возможности необходимо описать
в `@font-face` свойства шрифта, характеризиующие его внешний вид:
```css
@font-face
{
    font-family: myCustomFont;
    src: url(myCustomItalicFont.woff);
    font-style: italic;
}
```
Таким образом, все шрифтовые CSS свойства, описанные в `@font-face` указывают браузеру, что `myCustomItalicFont.woff`
необходимо применять только тогда, когда описанные в `@font-face` свойства шрифта совпадают со свойствами шрифта,
описанными в блоке:

```css
em
{
    font-style: italic;
}
```
В теге `<em>` будет использован именно `myCustomItalicFont.woff`, т.к. `<em>` унаследует от `<body>` свойство
`font-family: myCustomFont`, а `font-style: italic` укажет браузеру, что необходимо применить курсивную версию гарнитуры.

Подключение шрифта в `@font-face` без указания свойств `font-style`, `font-stretch`, и `font-weight` эквивалентно
подключению с указанием `font-style: normal; font-weight: normal; font-stretch: normal`.

#### Base64
Base64 — один из способов кодиравния различной информации в вебе. Помимо прочего, он позволяет кодировть файлы шрифтов и
тем самым интегрировать их прямо в описание стилей, непосредственно вставляя закодированный шрифт в поле `src` правила
`@font-face`:

```css
@font-face
{
    font-family: 'latoregular';
    src: url(data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHwwABMAAAAA4IwAAQA==) format('woff');
    /* На деле кода base64 значительно больше, для примера приведена лишь часть */
}
```
Такой вариант подключения может существенно увеличить размер CSS-файла, однако избавляет браузер от необходимости делать
дополнительный запрос за файлами шрифта. Польза этого приема заметна при использовании мобильного интернета, где достаточно
быстрое скачивание, но не самая быстрая обработка запросов.

#### Нюансы работы font-style и font-weight
Что произойдет, если для обычного начертания указать наклонный стиль отображения `font-style: italic`? В дело вступают
так называемые щадящие алгоритмы. А именно, браузер попытается «наклонить» обычное начертание, используя для этого
свой упрощенный алгоритм наклона. Нужно понимать, что разница с настоящим наклонным шрифтом может быть весьма заметна.
На рисунке ниже изображен один и тот же шрифт, в одном случае его наклонил браузер, в другом человек. Угадайте, где
потрудился браузер?  
![italic](https://cloud.githubusercontent.com/assets/769992/10103971/86173338-63c0-11e5-9832-ec1920fe3a5c.png)  

С жирностью ситуацуия аналогична:    
![bold](https://cloud.githubusercontent.com/assets/769992/10103970/8615d2cc-63c0-11e5-90a2-ba6481a8559c.png)

Существуют сервисы, позволяющие быстро подключить на страницу различные бесплатные шрифты. Наиболее известынм является
Google Fonts. После выбора шрифта серсив предлагает вставить на страничку ссылку на стиль вида
`<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>`
В подключаемом CSS файле находится набор правил `@font-face` с указанием источников шрифтов на серверах Google.

### Форматы веб-шрифтов
Некоторое время назад браузеры поддерживали различные по отношению друг к другу форматы шрифтов. Для кроссбраузерного
подключения приходилось использовать несколько форматов: `.svg`, `.ttf`, `.woff`, `.eot`. В настоящее время при использовании
последних версий браузеров достаточно использовать лишь `.woff`. Однако версии Android 4.3 и ниже не понимают
формат `woff` и для них необходимо подключить также `.ttf`. Таким образом рекомендуется использовать по крайней мере два
этих формата. Чтоб подключить более одного формата, необходимо перечислить источники через запятую:
```css
@font-face
{
    font-family: myCustomFont;
    src: url('myCustomFont.woff') format('woff'),
         url('myCustomFont.ttf') format('truetype');
}
```
Более распространенный формат лучше указать раньше, т.к. браузер будет использовать первый встреченный им и понятный ему
формат.

### Генерация различных форматов
Наиболее предпочтительным вариантом является получание от дизайнера\менеджера всех нужных форматов. Однако такой вариант
почти всегда невозможен и обычно в наличии есть только один формат шрифта, чаще всего `.ttf` или `.otf`. Существует
несколько способов получения `.woff` и других форматов. Наиболее простой и быстрый вариант — использование соответствеющих
веб-серсивов, наиболее популярным из которых является [fontsquirrel](http://www.fontsquirrel.com/tools/webfont-generator).
Сервис предлагает загрузить в него имеющийся шрифт после чего он генерирует архив с нужными форматами. Наибольшим
преимуществом этого сервиса является возможность указания необходимых символов (или их диапазона), что может существенно
уменьшить размер размер файлов шрифтов. Как правило достаточно выбрать кириллический, латинский диапазоны, а также набор
типографических символов. Главным недостатком такого рода сервисов является не всегда предсказуемый и приемлемый результат
генерации, заключающийся главным образом в некоторым искажении рендеринга символов. Результат может зависеть от конкретного
сервиса. Почитать о сравнении сервисом можно [здесь](http://habrahabr.ru/company/webfont/blog/217949/).

### Оптимизация загрузки и рендеринга шрифтов
Чтобы понять, как оптимизировать процесс загрузки шрифта, необходимо описать все его этапы:  
1. В процессе парсинга CSS стилей браузер обнаруживает правило `@font-face`. В этот момент браузер еще !не! начинает
загружать шрифт, описанный в правиле. Он это начнет делать только тогда, когда встретит его непосредственное использование
в стилях, т.е. вызов `font-family: myCustomFont` в каком-либо из блоков.  
2. Процесс загрузки шрифта схож с процессом загрузки любого другого ресурса: dns-резолвинг хоста, запрос к серверу на
скачивание файла, окончание скачивания.  
3. Парсинг скаченного файала и применение его к странице.  

Важно отметить, что с момента обнаружения браузером необходимости скачать шрифт до момента его применения текст в блоках
с этим шрифтом становится невидим и отображается лишь когда шрифт заружен:  
![font-loading](https://cloud.githubusercontent.com/assets/769992/10067732/36151c82-62b8-11e5-8ca7-fad9f0c569f5.gif)  
При этом заполняемое невидимым текстом пространство расчитывается исходя из параметров запасной гарнитуры.

Старые версии браузеров, а также Internet Explorer, сначала отображали запасной шрифт, а после загрузки шрифта применяли
новый. Момент подмены одного шрифта другим называется [FOUT](http://www.paulirish.com/2009/fighting-the-font-face-fout/)  
(flash of unstyled text).

Современные браузеры при обнаружении использования нестандартного шрифта не отображают текст с этим шрифтом вообще, пока
шрифт не будет загружен.

Итак, загрузка файлов шрифта и его отображение на странице — достаточно трудоемкий для браузера процесс, поэтому его
следует оптимизировать.

#### Исключение ненужных символов
Прежде всего необходимо максимально уменьшить размер шрифта путем исключения из него всех неиспользуемых
символов. Как было сказано ранее, сделать этому можно с помощью специальных веб-сервисов. Помимо этого существует
CSS-свойство `unicode-range`, позволяющее сообщить браузеру, какой диапазон необходимо загрузать, но оно работает не
во всех браузерах.

#### gzip
Описание настройки сервера выходит за рамки этой лекции, однако не будет лишним уточнить у своего системного, включен и
правильно ли настроен gzip. Использование архивации gzip может сэкономить до 60% трафика при загрузке шрифта.

#### Кэширование
Это также относится к настройке сервера, но полезно знать, что можно включить кэширование ресурсов на сервере, таким
образом, чтоб браузер не выкачивал шрифты заново при каждом новом заходе на страницу, а лишь проверял, не изменился ли
файл шрифтов. Возможно также настроить более агрессивное кеширование, когда браузер даже не делает запрос, проверяющий
изменения. Обычно такая проверка не нужна, а запрос занимает время, и шрифт не отобразится, пока такой запрос не
будет выполнен.

#### Использование Woff 2.0
С недавних пор современные браузеры начали поддерживать усовершенстованную версию формата `woff`. Его главным
преимуществом перед первой версией являеются улучшенные алгоритм компрессии, за счет чего файл может «весить»
на 30-50% меньше. Для наилучшей совместимости с браузерами при подключении следует указывать обе версии шрифта.
Как было сказано ранее, браузер загружает самый первый из понятных ему форматов. Поэтому стоит указать `.woff2` раньше
всех остальных. Затем `.woff` и самый старый и «тяжелый» `.ttf`:

```css
@font-face
{
    font-family: myCustomFont;
    src: url('myCustomFont.woff2') format('woff2'),
         url('myCustomFont.woff') format('woff'),
         url('myCustomFont.ttf') format('truetype');
}
```

#### Поднятие @font-face и его использование выше
Современные браузеры не начинают загружать шрифт, пока не обнаружат случай его использования на странице. Например, если
ваш css-файл «весит» 100 кБ, и вызов `font-family: myCustomFont` находится в конце этого файла, то браузер не начнет
загружать шрифт, пока не распарсит весь этот файл. Поэтому имеет смысл поместить `@font-face` и использующее CSS правило
как можно выше в файле. И сам файл разместить как можно выше в блоке `<head>`.  

### Универсальное свойство font
Свойство `font` позволяет определить множество параметров текста в одном правиле.
```
font: [font-style||font-variant||font-weight]||[font-stretch] font-size [/line-height] font-family
```
Полный пример использования:
```css
p
{
    font: italic small-caps bold semi-condensed 20px/24px Arial;
}
```

`font-style`, `font-variant`, `font-weight` и `line-height` необязательны, можно их не указывать. `font-size` и
`font-family` обязательны:
```css
p
{
    font: 20px Arial;
}
```

### Способы отображения символов шрифта на странице ❄ ☃ ❆ ☭
Существует несколько способов отобразить символ на странице.

#### Ввод с клавиатуры
Наиболее простейший и очевидный: набрать нужный символ при
помощи клавиатуры. При этом [существует возможность](http://symbolcodes.tlt.psu.edu/accents/index.html) при помощи
клавиатурных сочетаний набирать не только цифры, буквы и стандартные символы пунктуации, но и более специализированные,
например, €, ←, →, ↑, ∞ и т.д. Однако стоит отметить, что многие из таких символов отобразятся в браузере, только если
кодировка страницы utf-8.

### Именованные сущности
Более безопасным способом отобразить спецсимвол является использование так называемых именованных символьных сущеностей,
например:
`&copy;` знак копирайта (©),  
`&mdash;` длинное тире (—),  
`&le;` меньше или равно (≤)

Именованная сущность начинается с амперсанта, далее следует название сущности и в конце ставится точка с запятой.
При рендеринге страницы браузер заменит такие вхождения на соответствующие символы. Стоит отметить, что не у каждого
символа есть именной вариант.

> Точка с запятой в конце вызова символа является необязательной, но рекомендуется всегда ее ставить во избежани
 ошибок.

#### Unicode
Юникод — самый распространенный и универсальный стандарт кодирования символов в мире, позволяющий представить знаки
почти всех письменных языков. Помимо этого в нем закодировано огромное кол-во различных символик: флаги, логотипы,
смайлики и пр. Символы в юникоде представлены в десятичной (decimal) и шестнадцатеричной системах (hex). Например, знак
копирайта в десятичной системе имеет вид `#169`, а в шестнадцатиричной `#xA9`. `x` перед hex-представлением указывает,
что далее следует шестнадцатиричное число.  
Вызов юникод-символов в HTML'e также начинается с амперсанта и заканчивается точкой с запятой. Например, знак копирайта
© вызывается так: `&#169;` или `&#xA9;`.

Использование юникода гарантирует корректность отображения символа вне зависимости от кодировки страницы при условии, что
символьная таблица операционной системы располагает нужным символом. Например, в Windows XP могу не отобразиться какие-то
особо редкие символы, добавленные в unicode после окончания его поддержки компанией Microsoft.

#### Экранирование
Существуют ситуации, когда необходимо отобразить не сам символ, а то, как он закодирован. Иными словами `&#169;` вместо
©. Для этого необходимо закодировать символы, составляющие код символа. Таким образом, чтоб отобразить код копирайта
в браузере, необходимо написать в коде `&#38;&#35;&#49;&#54;&#57;`.  Таким же образом можно отобразить, например, HTML-
теги. Для этого пригодятся кодировки знаков «больше» и «меньше»: `&lt;` и `&gt;`.

#### Вызов символов в CSS
В CSS существует псеводоэлемент `::before`, который в свою очередь имеет обязательное свойство `content`, позволяющее
вставлять символы. Если страница представлена в `utf-8` кодировке, то спецсимволы можно использовать в этом свойстве
как есть:
```css
div::before
{
    content: "©";
}
```

Использование юникода также возможно, но формат его вставки отличается от формата вставки в HTML и допускается только
hex-кодирование. Перед кодом ставится символ обратной косой черты. Пример:
```css
div:before
{
    content: '\A9';
}
```

# Текст
Текст — это материализованная человеческая мысль. Стандарт HTML предназначен именно для удобной подачи текста.

## Выравнивание
Как и во всех текстовых процессорах, текст в вебе можно выравнивать по левому и правому краям, по центру, а также по
ширине. Осуществляется это с помощью свойства `text-align`, которое принимает соответствующие значения: `left`, `right`,
`center` и `justify`. При выравнивании по ширине пробелы в каждой строке увеличиваются таким образом, чтоб правый край
последнего символа строки был прижат к правому краю.   
Выравнивание можно применить только к блочным элементам, оно действует на все строчные элементы.
Так, в следующем примере это свойство не будет иметь никакого эффекта, т.к. `<span>` строчный элемент.
```css
<span style="text-align: right;">
    Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies
    nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim.
</span>
```
Вместо `<span>` следует использовать блочный тег, например, `<p>`.

## Подчеркивание и перечеркивание и надчеркивание
Подчеркивание в вебе по умолчанию применяется у ссылок. Таким образом его принято применять к активным
(т.е. кликабельным) элементам. Реже применяется для увеличения акцента словам и фразам. Для придания подчеркивания
используется свойство `text-decoration` со значением `underline`.  

Перечеркивание, как правило, используется, чтоб показать изменения, произошедние в тексте. Например, старая и новая цены
товаров. Чтоб отобразить перечеркивание у свойства `text-decoration` следует указать значение `line-through`.

Надчеркивание (значение `overline`) в основном используется в математических нотациях.

Значением по умолчанию является `none`. Стоит отметить, что `text-decoration` не наследуется дочерним элементам, и его
нельзя отменить для отдельных слов, если всему блоку указано подчеркивание или перечеркивание. Например:

```html
    <p style="text-decoration: line-through;">
        Текст перечеркнут. <span style="text-decoration: none;">Текст по-прежнему перечеркнут</span>.
    <p>
```

## Преобразование текста
Преобразование текста позволяет управлять типом букв (строчные\прописные). Для этого используется свойство
`text-transform`.

<table>
    <caption align="left">Возможные значения:</caption>
    <tr>
        <td>capitalize</td>
        <td>Первый символ каждого слова в предложении будет заглавным. Остальные символы свой вид не меняют.</td>
    </tr>

    <tr>
        <td>lowercase</td>
        <td>Все символы текста становятся строчными (нижний регистр).</td>
    </tr>

    <tr>
        <td>uppercase</td>
        <td>Все символы текста становятся прописными (верхний регистр).</td>
    </tr>

    <tr>
        <td>none</td>
        <td>Значение по умолчанию. Не меняет регистр символов.</td>
    </tr>
</table>

<strong>Пример</strong>

```html
<p style="text-transform: capitalize;">
    Каждое слово этого текста начинается с заглавной буквы.
</p>
```
_Результат_:  
Каждое Слово Этого Текста Начинается С Заглавной Буквы.

## Абзацный отступ
Абзацный отступ — это сдвиг первой строки абзаца для логического разделения текста на части. Для задания величины отступа
необходимо воспользоваться свойством `text-indent`.

```html
<p style="text-indent: 20px;">
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa.
</p>
```

Результат:  
![text-indent](https://leto21e.storage.yandex.net/rdisk/5ad42b0b0da19ac2c97636768c441fa3cb77581b84f7bdd849f9a3169d477185/inf/WElB8z2QEEeJUmZawOp-Y3rJL_RNQj-9UPX4hSN2iLqEip3GYA0bCW90Ro85fHa6OSKRuC0DtcF2MhS44chFJA==?uid=0&filename=2015-10-05%2000-14-33%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=de0f8b58b6c4c6a2cdcbf1abf529b0df&force_default=no&ycrid=na-689447e542b7fd19933b912f183d9197-downloader13d)

## Цвет
Указание цвета текста задается с помощью свойства `color`.  Цвет в вебе может быть представлен в различных палитрах.

### Влияния цвета на другие свойства
Цвет, указанный в `color`, влияет не только на цвет самого текста. В него окращиваются линии подчеркивания, надчеркивания
и перечеркивания. Помимо этого он наследуется, как цвет по умолчанию, для многих составляющих элемента, например, для
бордюров, тени блока и др. Пример:
```css
p
{
    color: red;
    border: 1px solid; /* Цвет бордера будет красным */
    box-shadow: 2px 2px 3px; /* красная тень блока */
}
```
При этом свойства, которые не наследуют цвет от `color` автоматически, можно сделать это вручную при помощи ключевого
слова `currentColor`:  

```css
p
{
    color: red;
    background-color: currentColor; /* Цвет фона станет красный */
}
```

`color` является наследующися свойством. Поэтому, если у дочерних элементов не указан свой `color`, то `currentColor`
будет взят от цвета родительского элемента.

## Тень текста
Можно добавить к тексту тень с различными параметрами: смещение, размытие, цвет. В этом поможет свойство `text-shadow`:
```css
text-shadow: [сдвиг по оси X] [сдвиг по оси Y] [радиус размытия] [цвет];
```
`[радиус размытия]` является необязательным параметром.  

Создадим красную тень со сдвигом в 1 пиксель вправо вниз:
```css
p
{
    text-shadow: 2px 2px red;
}
```
![simple](https://cloud.githubusercontent.com/assets/769992/10760921/ba542f00-7ce0-11e5-8240-e89a53e04b05.png)  

Добавим размытие в 3 пикселя:  
```css
p
{
    text-shadow: 2px 2px 3px red;
}
```
![text-shadow-blur](https://leto12h.storage.yandex.net/rdisk/a1238ad32e48ded8da065e458b8e0d9f14f023c6288a3cbf799afc3d46549d93/inf/OCJ3bkUarCHD2TRc9pSQ8c0LhXRY9qLMyqOvPUzTioJXRIel4GR26813EUKtaE0pLNloFc2pLmvlJeBQdExKpw==?uid=0&filename=2015-10-07%2019-49-43%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=bb1c32a9059f69de31e2a0150d36c4b6&force_default=no&ycrid=na-a99a481dc56cc0cc45025c63df48228e-downloader10e)  

Сдвиг может быть в том числе отрицательным. Можно также указывать две и более нотации теней, перечислив их через запятую:  
```css
p
{
    text-shadow: 2px 2px 3px red,
                 -2px -2px 3px green;
}
```
![text-shadow-double](https://leto26e.storage.yandex.net/rdisk/e3d7b1de773aad4aa317392b815ca2bd94d3ca6d009f082e7b49703346cde57f/inf/Y-iH7eZ3QGxnLxEFykXYIHlGR4GLNMFQXhMMd8KRgC6lmZdsu95nucj4HVvmL2LRTs2HgBSrUmjMS-eNXziKbg==?uid=0&filename=2015-10-07%2019-56-01%20Untitled-1%20%40%20300%25%20%28Layer%201%2C%20RGB%208%29%20%2A.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=bb1c32a9059f69de31e2a0150d36c4b6&force_default=no&ycrid=na-201174e336a7b76582f4a89e648db173-downloader6g)  

С помощью теней можно придать тексту различные эффекты, например, объемный наклон:
```css
p
{
    text-shadow: 0 1px 0 #ccc,
                 0 2px 0 #c9c9c9,
                 0 3px 0 #bbb,
                 0 4px 0 #b9b9b9,
                 0 5px 0 #aaa,
                 0 6px 1px rgba(0,0,0,.1),
                 0 0 5px rgba(0,0,0,.1),
                 0 1px 3px rgba(0,0,0,.3),
                 0 3px 5px rgba(0,0,0,.2),
                 0 5px 10px rgba(0,0,0,.25),
                 0 10px 10px rgba(0,0,0,.2),
                 0 20px 20px rgba(0,0,0,.15);
}
```
![](https://leto23f.storage.yandex.net/rdisk/0490319f76b47ebff4085ffbd09b10e59bf7f89cb71cbfea280fd3e03ab3691c/inf/0EocAXz22BD-V49fiSnNKuWR_d5DJ2VAumgyybbQ1XvtXuT3Mhk3AN1WLMgQqSHXXEPMkVq9pdEqsnlxsuMOVQ==?uid=0&filename=2015-10-07%2020-10-33%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=bb1c32a9059f69de31e2a0150d36c4b6&force_default=no&ycrid=na-a2144c1c5a6ea2728878a9076350992b-downloader8g)

Неоновое свечение:

```css
p
{
    text-shadow: 0 0 10px #fff,
                 0 0 20px #fff,
                 0 0 30px #fff,
                 0 0 40px #ff00de,
                 0 0 70px #ff00de,
                 0 0 80px #ff00de,
                 0 0 100px #ff00de,
                 0 0 150px #ff00de;
}
```

![neon](https://cloud.githubusercontent.com/assets/769992/10760920/ba531516-7ce0-11e5-8716-46e7e6cb5b03.png)  

## Многоколоночность
Многоколоночность — возможность разбивать блоки текста на колонки. Этот прием часто применяется при верстке газет,
журналов и пр. по той причине, что читать сильно широкие блоки текста некомфортно.  
![newspaper](https://cloud.githubusercontent.com/assets/769992/10244692/75067586-691a-11e5-9021-564b82afb2c8.jpg)  

### Разбиение на колонки

Предположим, у нас есть обычный текст:
```html
<p>
    В европейских языках чтение текста происходит слева направо, в то время как есть языки, где текст читается справа
    налево. При смешении в одном документе разных по написанию символов (русского с ивритом, к примеру) в системе юникод,
    их направление определяется браузером из характеристик и содержимого текста.
</p>
```
![just-text](https://cloud.githubusercontent.com/assets/769992/10244691/7505bfba-691a-11e5-8932-e14736fa748b.png)  

Чтоб разбить его на колонки, необходимо указать нужно кол-во колонок в свойстве `column-count`:
```css
p
{
    column-count: 2; /* В браузерах Firefox и Chrome (и др. на его основе) свойство работает только с префиксами. */
}
```

![text-column-1](https://cloud.githubusercontent.com/assets/769992/10244690/75058536-691a-11e5-8079-45e996affd7d.png)  

### Управление шириной
Если необходимо, чтобы текст разбивался на колонки только тогда, когда родительский блок становится достаточно широким,
можно прибегнуть к свойству `column-width`. Оно задает минимальную ширину колонки. Если блок не может вмесить в себя
нужное кол-во колонок, т.е. ширина блока меньше, чем кол-во колонок умноженное на `column-width`, то браузер уменьшает
кол-во колонок до количества, способного поместиться в блок. Предположим, есть блок с текстом шириной `1000px`. Ему
заданы 5 колонок с помощью `column-width: 5` и размер колонки `300px` (`column-width: 300px`). Расчетная ширина колонок
получается 1500px, что превышает ширину родительского блока. Влезть могут только три колонки, и именно столько покажет
браузер в такой ситуации. Таким образом значения этих двух свойств принято называть не точными, а оптимальными.

### Расстояние между колонками
Для изменения расстояния между колонками используется свойство `column-gap`. Его величина влияет на расчет кол-ва
колонок.  

### Разделитель колонок
По умолчанию разделитель между колонками отсутствует. С помощью свойства `column-rule` можно его добавить, задав
необходимый вид, а именно ширину, тип и размер через пробел, например: `column-rule: 1px solid #ccc`.

### Игнорирование колонок
Свойство `column-span` со значением `all` позволяет расположить текст поверх колонок (например, заголовок):
```css
div
{
    column-count: 2;
}
h3
{
    column-span: all;
}
```
```html
<div>
    В европейских языках чтение текста происходит слева направо, в то время как есть языки, где текст читается справа
    налево.

    <h3>Заголовок посреди текста</h3>

    При смешении в одном документе разных по написанию символов (русского с ивритом, к примеру) в системе юникод,
    их направление определяется браузером из характеристик и содержимого текста.
</div>
```
![](https://leto35e.storage.yandex.net/rdisk/2d789a0d179c4cf2594763c810ed85ef280d44a8233714ba69709e56ce3fd180/inf/McSqB0Ur_FOuKriNf1_Wpg6EUU-JY38ZJhbY01rSC0wS_SgapzTS1kH_y7B_vDTCPpE2W8g_e6WI08TBroe2Dw==?uid=0&filename=2015-10-22%2001-11-19%20Edit%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=0d7ab062b81dfa5f9f3ea76080da1f9c&force_default=no&ycrid=na-8e19169823b2cb57b1cbeb4263d372f2-downloader10d)  

## Перенос текста
Перенос — это разрыв части текста, при котором её начало оказывается на одной строке, а конец — на другой.

По умолчанию в вебе переносы может быть в местах символов пространства (пробелы, табуляция и прочие) и дефисов. В
зависимости от браузера могут быть и около других символов. Например, и Firefox и Chrome переносят текст перед символом
тире, но только Chrome переносит текст и после.

Для того, чтоб перенести текст в произвольном месте на следующую строку, необходимо указать тег `<br>` в месте переноса:  
```html
<p>
    Далеко-далеко за словесными горами<br>в стране гласных и согласных живут рыбные тексты.
</p>
```
![](https://leto4h.storage.yandex.net/rdisk/d4c3862398e370fceee1e7304fc72bdfdf9668cdbbe79dc87fa47dbad520f3f2/inf/MoBcdcTUZN6suQJwF4eA6Q8l-0_VFVeF1lmUa8gExNUF3HlNFIsjQkR7arJh2nd57wNCxdY8MwZ5wNltTUdHbw==?uid=0&filename=2015-10-10%2022-34-33%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-f6135ccac8d10ec6faea2c94470d098b-downloader9d)  

### Переносы внутри слов
Переносы внутри слов используется для того, чтобы скоратить к минимуму разброс ширины пробелов у выравненого по ширине
текста. А также, чтоб сократить «лесенки» правого края текста, выровненого по левому краю. На следующей иллюстрации с текстом можно
заметить, что пробелы в тексте, выровненном по ширине, очень заметны, и их ширина варьируется:  
![](https://leto25f.storage.yandex.net/rdisk/75eadfdf8622907ce13b951e3aaa57afa69d7b42e8f8c67b75a0dde785b70042/inf/vdQqcWrQVydUZ7DkE_grSUqnEniDJ9nvpHNhIFhjCKE_Thx0D-LYfBJAueLrja5ubxU3nyZ3Ji9v9T6I0vl6ug==?uid=0&filename=2015-10-09%2014-40-34%20Edit%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-95379198448005ae61d6f4d0bba9e326-downloader3d)  

При включении автопереносов, ширина пробелов скачет в гораздо меньшей степени, что делает текст более приятным и читаемым:  
![](https://leto24e.storage.yandex.net/rdisk/17efdbefd5eb738f0f2bb91f175acf9762b934f349c30d1e56d8a46666392847/inf/3AalqIScV9u6J5uGOOzfdl1JJE8g-63A9DtSVJCDX86HhscmrNfhKHgKGC-knLoCBBms5IVxdQva4ylVOmW9fA==?uid=0&filename=2015-10-09%2014-44-31%20Edit%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-54671b444049545a8d2ae49022bd04a1-downloader1d)  

Чтоб задействовать автопереносы, необходимо воспользоваться свойством `hyphens`, выставив ему значение `auto`. В этом
случае браузер расставлять переносы своими силами. Для этого браузеру необходимо подсказать правильный язык документа
или блока с текстом с помощью атрибута `lang`:  
```html
<p lang="ru">
    Далеко-далеко за словесными горами в стране гласных и согласных живут рыбные тексты.
    Вдали от всех живут они в буквенных домах на берегу Семантика большого языкового океана.
</p>
```
В большинстве современных европейских языках перенос обозначается дефисом после начальной части разорванного
слова.  
Правила переноса букв могут различны в разных языках. Например, в русском языке буквы переносятся по слогам. При этом
слоги из одной буквы переносить недопустимо. В английском языке некоторые переносы могут требовать дублирования буквы,
после которй происходит перенос, например: `eighteen → eight-//teen`.  

> Возможность побуквенного переноса появилась в браузерах сравнительно недавно, поэтому почти во всех из них `hyphens`
работает только с префиксами. И поддержка того или иного языка, в зависимости от браузера, может отсутствовать. Например,
автопереносы в русском языке пока что не работают в Chrome.  

### Мягкие переносы
Существует возможность «подсказать» браузеру, где допустимо делать переносы. Для этого необходимо расставить служебные
символы `&shy;` в соответствующих местах:  
```html
<p>
    <-- Далеко-далеко за словесными горами -->
    Да&shy;ле&shy;ко-да&shy;ле&shy;ко за сло&shy;вес&shy;ны&shy;ми го&shy;ра&shy;ми.
</p>
```
![](https://leto41e.storage.yandex.net/rdisk/bfbd32380290ad755bca08e3310cacab3960ced9cb199fb665bd5781310e4f52/inf/RS4aSgWMNYQchpLGhUR-3ZNNEfG4PRiqJ3qXzQ3bcEArm9wtpF63s2GpOfdFW6t1k5kBtbEPU3DAs-M99B6n5A==?uid=0&filename=2015-10-10%2014-14-12%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-e9a0822c3e7a09e123f7c32112e20f54-downloader6d)  
> Чтоб мягкие переносы работали, свойство `hyphens` должно иметь значение `manual`. Оно является значением по умолчанию,
таким образом указывать его не обязательно.  

В редких случаях может понадобиться добавить мягкий перенос, не добавляющий символ `-` в конце строкии при переносе слова.
Чтоб этого вместо вместо `&shy;` необходимо использовать тег `<wbr>`. Такой мягкий перенос может пригодиться при переносе
веб-адресов, т.к. символ дефиса может быть воспринят, как часть адреса:
```html
    <p>http://this<wbr>.is<wbr>.a<wbr>.really<wbr>.long<wbr>.example</p>
```
![](https://leto47e.storage.yandex.net/rdisk/a47aa347a4cdca2e1021b3c8b13c47bb2003816ba964a959d3119ef65edfdb7f/inf/D2oIYu2UDu3jfzo2XUnS23wO8U9CrnzI9in_jUaVnjQt0wAiLZrI5B3ASdhkbaZx94WxbPj9YgH9NWKRgaiKiw==?uid=0&filename=2015-10-10%2015-43-42%20Edit%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-c376f4f2ee1758935bf523b6aaced1fc-downloader3d)  
Однако расставлять такие теги вручную неудобно. В большинстве случаев более удобным будет воспользоваться свойством
`word-break` со значением `break-all`. Следует иметь в виду, что текст при этом будет переноситься перед любым символом,
который не помещается в строку:  
![](https://leto40f.storage.yandex.net/rdisk/6bbf2a1996061fb73d31b7b712f88f0d6424a7397176aace7688205d5ba8f55f/inf/HkeO3oV4MzgMcLk7i2GnPUt-1HjUMLFllWB5gY9RFWwAR_-2zp22PwhiNge6gZg-_-sc8l8nmetgPfbS3waXTw==?uid=0&filename=2015-10-11%2001-48-52%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-232bb288e4c5a283f71aa57654768d7d-downloader9d)  
поэтому не следует указывать это правило на целые блоки с текстом. Лучше обернуть требуемые места в тег с таким стилем:
```html
<p>
    По следующей ссылке вы увидите котиков: <span style="word-break: break-all;">https://yandex.ru/images/search?text=котики</span>
<p>
```
![](https://leto27e.storage.yandex.net/rdisk/acd17f37dfd45811770f4c6168c88e21ca347811e3984c86ccd23f9526bf54ea/inf/bKb_OaOQqsqXKplWdg6-7p2c1bKoN5YMF-wJ_EBz-5Pzpk1SzcSgV-4U60TxPe57cJ9QrV9ZiJLWU9I1zsG1Rw==?uid=0&filename=2015-10-11%2001-53-08%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-c9abb22fc1ce005fddfa1629daec54fd-downloader11d)
> Существуют сервисы (а также приложения), расставляющие мягкий переносы в тексте. Например, [такой](http://quittance.ru/hyphenator.php).

### Запрет переноса
Существует ряд ситуаций, когда необходимо запретить перенос в тех местах, где по умолчанию текст переносится. Например,
в типографике принято, чтоб в конце строк не осталалось висящих пробелов. Рассмотрим следующий пример:
```html
<p style="width: 100px;">
    Вдали от всех живут они в буквенных домах.
</p>
```
И предлог «в» подвис в конце одной из строк:  
![](https://leto34g.storage.yandex.net/rdisk/9488c5bbac50fa537649e341dc5a918180b723d6b9da0eeef0febf4c2efd6ef1/inf/ZCN0PVyQrMU2U0OlEM8Cr9-L07vOWc2syZSDRgyfx_rQDdSRVAGNNBvwIqgLR5W57pD-MS072NV70a-cXfVRvg==?uid=0&filename=2015-10-10%2019-20-32%20Untitled-1%20%40%20100%25%20%28Layer%203%2C%20RGB%208%29%20%2A.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-cfe204853c6e1a98bbe74962d0e55af6-downloader10d)  
Чтоб решить эту проблему, необходимо, чтобы пробел _после_ предлога не приводил к переносу текста. Тогда предлог и
следующее слово будут неразрывны. Добиться этого можно несколькими способами:  

* Использование символа неразрывного пробела `&nbsp;` (Non-breaking space). Это специальный символ, который выглядит,
как пробел, но предотвращающий перенос текста там, где он расположен:  
```html
<p style="width: 100px;">
    Вдали от всех живут они в&nbsp;буквенных домах.
</p>
```
Т.к. сочетание «в буквенных» стало единым целым, оно перенесется полностью:  
![](https://leto31d.storage.yandex.net/rdisk/eb2d652d0d41f0867befcc58a6012951251185276949b33bdc7971becaa8a375/inf/u3fTUV9PXKJYRQNMetecDriZ-OTuka0Kscd5j9l29FHw6FbZ86JCObWaEOpeZuKW8-w18KNki7TjepyETJfVFA==?uid=0&filename=2015-10-10%2019-56-06%20Create%20a%20new%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-2b1f408f5f71f5d429ad855dd41190dd-downloader3d)  
> Существуют сервисы (а также приложения), позволяющие расставить в правильных местах текста неразрывные пробелы.
> Одним из таких сервисов является «[Типограф](http://www.typograf.ru/)».  

* Использование CSS-свойства `white-space` со значением `nowrap`, которое предотвращает перенос текста. Т.к. необходимо
предотвратить перенос только у фразы «в буквенных», то необходимо обернуть её в какой-нибудь строчный тег с этим
свойством:  

```html
<p style="width: 100px;">
    Вдали от всех живут они <span style="white-space: nowrap;">в буквенных</span> домах.
</p>
```
> Подробнее о свойтве white-space будет рассказано ниже.  

## Управление символами пространства
Свойство `white-space` определяет, как ведут себя символы пространства (пробелы, табуляця, разрывы строки и пр.).
> Символ разрыва строки вставляется, если нажать `Enter` на клавиатуре. Перенос при этом будет виден в редакторах кода,
> но в браузере перенос будет только внутри тега `<pre>` и особых значениях свойства `white-space`.

<table>
<tbody>
    <tr>
        <td>normal</td>
        <td>
            Значение по умолчанию. Любая подряд идущая последовательность символов пространства схлопывается в один
            пробел. Символы разрыва строки не переносят текст.
        </td>
    </tr>
    <tr>
        <td>nowrap</td>
        <td>
            Любая подряд идущая последовательность символов пространства схлопывается в один пробел. Символы пространства
            не вызывают потенциального переноса текста. Перенос можно осуществить только с помощью тега <code>&lt;br&gt;</code>.
        </td>
    </tr>
    <tr>
        <td>pre</td>
        <td>
            Подряд идущие символы пространства не схлапываются. Символы пространства не вызывают потенциального переноса
            текста. Аналогично работе тега <code>&lt;pre&gt;</code>.
        </td>
    </tr>
    <tr>
        <td>pre-line</td>
        <td>
            Работает, как <code>normal</code> (пробелы схлапываются в один), но символы разрыва строки приводят к переносу.
        </td>
    </tr>
    <tr>
        <td>pre-wrap</td>
        <td>
            Работает, как <code>pre</code>, но текст переносится автоматически, если не помещается в строку.
        </td>
    </tr>
</tbody>
</table>
Свойство может быть применено ко всем типам элементов.

### Переполнение текста
Иногда возникают ситуации, когда текст значительно превышает ширину родительского блока. Например, имеется таблица с
именами, и по дизайну она должна быть компактной с ячейками не более 150 пикселей:  
![](https://leto4e.storage.yandex.net/rdisk/a117e346a0069baff63acecffd483aeb0852fed6fa58843b1f7b6464c76ce886/inf/BJZI8Pv5WXD20FO_G0-mLYuqdJ6rMAaImULHwOjuoCi0SyzPh-CuWudtnnpLoDUD0jx7fsXEz9IK9ITTxfijig==?uid=0&filename=2015-10-15%2011-43-30%20HTML%20Tables.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=9e2ec8a501b14ee0111788dd5ee44a7a&force_default=no&ycrid=na-9f224894f4f0c9a1c0339b514a638377-downloader13d)  
Но может случиться так, что появится запись с очень длинной фамилией:  
![](https://leto13f.storage.yandex.net/rdisk/faefd1cd3399ecad104e8cb7d8e825aa5a24dbfb4a449c643bc4013b2f142825/inf/LdlF3gbBIPWurGa8gp71GjzpgEVK4rXMB8EwSHow-R5Os15nZwADZ3fMTB99tiTefXerBr0YL5b-mzMCC1ZJ-g==?uid=0&filename=2015-10-15%2011-47-51%20HTML%20Tables.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=9e2ec8a501b14ee0111788dd5ee44a7a&force_default=no&ycrid=na-d48125654252e3ad83f6cda4c02a3c7f-downloader9d)  
Данная ситуация назвается «переполнение». Конечно, переполнение контента следует скрыть при помощи правила
`overflow: hidden`:    
![](https://leto23d.storage.yandex.net/rdisk/5e4bc8737bad66de80910d686af6408ce5ef52e1aff762acaed3bafd8b01a41d/inf/TCGthq-ERpY2PkEiOMec5aVmUF4Y3oIf-Cooo0kpxz5FJrahtCOYaO0mlynhsOezwwlZ-rJAuZ8naBcKhSbK1Q==?uid=0&filename=2015-10-15%2011-51-38%20HTML%20Tables.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=9e2ec8a501b14ee0111788dd5ee44a7a&force_default=no&ycrid=na-d4ebcdaa5a6b0587124cbdc6d54ebbfc-downloader6d)  
Но вид этой ячейки по-прежнему оставляет желать лучшего. Буква обрезалась посередине. Хотелось бы как-то корректно
отображать такие ситуации. Именно для таких случаев предусмотрено свойство переполнения текста `text-overflow`.
Единственным (помимо значения по умолчанию `clip`) значением является `ellipsis`. Оно помещает символ многоточия в месте,
где текст «обрезается»:  
![](https://2.downloader.disk.yandex.ru/preview/722b0297666fef9d3f5156d54f3a4f5aed388f5c4cea5f547c02fafd52aebab8/inf/Mr4lLa2zxxoFfgxYMMcHkibEOYQ1yqTDh7lY3wO2QLo_zvkdOGhC1VJYI3LnvzFvqgT2RgiC5nwkDnidnOiVxg%3D%3D?uid=226545079&filename=2015-10-15%2011-56-39%20HTML%20Tables.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&size=1191x505)  
Таким образом пользователю становится более очевидно, что в ячейке присутствует какой-то длинный непоместившийся текст.
При этом если выделить такое слово вместе с символов многоточия и скопировать в буфер обмена, то слово скопируется все
слово целиком, что удобно.

## Псевдоэлементы текста

### Псевдоэлемент первой строки
CSS позволяет задать оформление первой строки блока с помощью специального псевдоэлемента `::first-line`. Возможности
оформления при этом ограничиваются в основном видоизменением свойств шрифта и текста и представлены следующими
свойствами:
* font properties
* color properties
* background properties
* word-spacing
* letter-spacing
* text-decoration
* vertical-align
* text-transform
* line-height
* clear

_Пример_:  
```html
p::first-line
{
    color: red;
}

<p>
    Первая строка красная.<br>Вторая строка черная.
</p>
```
### Псевдоэлемент первого символа
Псевдоэлемент `::first-letter` позволяет указать стили для первой буквы блока.
```html
<style>
p::first-letter
{
    color: #fff;
    background: #f00;
    padding: 0 4px;
    margin: 0 2px 0 0;
}
</style>

<p>
    Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor.
</p>
```
![](https://leto40d.storage.yandex.net/rdisk/690d252a5605f86831cac0e730f8471542c792c355974d3c3fb098eaf4143abb/inf/-db5rfJvynJSTSr-LBUwVEqnEniDJ9nvpHNhIFhjCKGpNhJpMUWOeVWxvbN_dd8poTGxdVEC9ONXiOqpR8TkFQ==?uid=0&filename=2015-10-11%2002-41-43%20Edit%20fiddle%20-%20JSFiddle.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&tknv=v2&rtoken=db0ab222e9b599020d131fc3f908b7a0&force_default=no&ycrid=na-38b964be9e40f883cc30613704d29bd6-downloader6d)  
В отличие от `::first-line` в селекторе можно также указывать отступы, бардюры, обтекания и некоторые другие свойства.
